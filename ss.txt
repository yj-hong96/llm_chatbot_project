// src/pages/ChatPage.jsx
import { useNavigate, useLocation } from "react-router-dom";
import { useState, useEffect, useRef } from "react";

import ChatHeader from "../components/chat/ChatHeader.jsx";
import ChatMessages from "../components/chat/ChatMessages.jsx";
import ChatInput from "../components/chat/ChatInput.jsx";

const STORAGE_KEY = "chatConversations_v2";
// ‚úÖ API BASE: .env ÏóêÏÑú Í∞ÄÏ†∏Ïò§Îêò, ÏóÜÏúºÎ©¥ Î°úÏª¨ Í∏∞Î≥∏Í∞í
const API_BASE =
  import.meta.env.VITE_API_BASE_URL || "http://127.0.0.1:5000";

// ÏÇ¨Ïù¥ÎìúÎ∞î Ìè≠ ÏÑ§Ï†ïÍ∞í
const SIDEBAR_MIN_WIDTH = 180;
const SIDEBAR_MAX_WIDTH = 360;
const SIDEBAR_INIT_WIDTH = 220;

// ---------------------------------------------------------
// Ïú†Ìã∏: ÏÉà ÎåÄÌôî(Í∏∞Î≥∏ Ïù∏ÏÇ¨ Ìè¨Ìï®) ÏÉùÏÑ±
// ---------------------------------------------------------
function createNewConversation() {
  const now = Date.now();
  return {
    id: String(now),
    title: "ÏÉà ÎåÄÌôî",
    createdAt: now,
    updatedAt: now,
    messages: [{ role: "bot", text: "ÏïàÎÖïÌïòÏÑ∏Ïöî! Î¨¥ÏóáÏùÑ ÎèÑÏôÄÎìúÎ¶¥ÍπåÏöî?" }],
    folderId: null,
  };
}

// ---------------------------------------------------------
// Ïú†Ìã∏: Ï¥àÍ∏∞ ÏÉÅÌÉú Î°úÎìú(localStorage Ìò∏Ìôò)
// ---------------------------------------------------------
function getInitialChatState() {
  if (typeof window !== "undefined") {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);

        // ÏÉà Íµ¨Ï°∞ { conversations, folders, currentId }
        if (
          parsed &&
          Array.isArray(parsed.conversations) &&
          parsed.conversations.length > 0
        ) {
          const convs = parsed.conversations || [];
          const folders = parsed.folders || [];
          let currentId = parsed.currentId;
          if (!currentId || !convs.some((c) => c.id === currentId)) {
            currentId = convs[0].id;
          }
          return { conversations: convs, folders, currentId };
        }

        // ÏòàÏ†Ñ Íµ¨Ï°∞: Î∞∞Ïó¥Îßå Ï†ÄÏû•Îèº ÏûàÏóàÎçò Í≤ΩÏö∞
        if (Array.isArray(parsed) && parsed.length > 0) {
          const convs = parsed;
          return { conversations: convs, folders: [], currentId: convs[0].id };
        }
      }
    } catch (e) {
      console.error("Ï†ÄÏû•Îêú ÎåÄÌôî Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•ò:", e);
    }
  }
  const conv = createNewConversation();
  return { conversations: [conv], folders: [], currentId: conv.id };
}

// ---------------------------------------------------------
// ÏóêÎü¨ ÌÖçÏä§Ìä∏ ÌååÏã± ‚Üí ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†Å ÏïàÎÇ¥
// ---------------------------------------------------------
function makeErrorInfo(rawError) {
  const text =
    typeof rawError === "string" ? rawError : JSON.stringify(rawError, null, 2);

  let errorCode = null;
  const codeMatch =
    text.match(/Error code:\s*(\d{3})/) ||
    text.match(/"status"\s*:\s*(\d{3})/) ||
    text.match(/"statusCode"\s*:\s*(\d{3})/);
  if (codeMatch) errorCode = codeMatch[1];

  const base = { detail: text, code: errorCode };

  if (
    text.includes("tokens per minute") ||
    text.includes("TPM") ||
    text.includes("rate_limit_exceeded") ||
    text.includes("RateLimit") ||
    text.includes("Too Many Requests") ||
    (text.toLowerCase().includes("quota") && text.toLowerCase().includes("token"))
  ) {
    const code = errorCode || "429";
    return {
      ...base,
      code,
      title: `ÌÜ†ÌÅ∞ ÏÇ¨Ïö© ÌïúÎèÑÎ•º Ï¥àÍ≥ºÌñàÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: ${code})`,
      guide:
        "ÏßßÏùÄ ÏãúÍ∞ÑÏóê ÎÑàÎ¨¥ ÎßéÏùÄ ÌÜ†ÌÅ∞ÏùÑ ÏÇ¨Ïö©Ìï¥ÏÑú Ï†úÌïúÏóê Í±∏Î†∏ÏäµÎãàÎã§. ÏßàÎ¨∏ÏùÑ Ï°∞Í∏à Ï§ÑÏù¥Í±∞ÎÇò, Ïó¨Îü¨ Î≤àÏúºÎ°ú ÎÇòÎàÑÏñ¥ÏÑú Î≥¥ÎÇ¥Í±∞ÎÇò, Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.",
      hint:
        "Îß§Ïö∞ Í∏¥ ÎåÄÌôî Ï†ÑÏ≤¥Î•º Ìïú Î≤àÏóê Î≥¥ÎÇ¥Í∏∞Î≥¥Îã§, Íº≠ ÌïÑÏöîÌïú Î∂ÄÎ∂ÑÎßå ÏöîÏïΩÌï¥ÏÑú Î≥¥ÎÇ¥Î©¥ Îçî ÏïàÏ†ïÏ†ÅÏúºÎ°ú ÎèôÏûëÌï©ÎãàÎã§.",
    };
  }

  if (
    text.includes("Request too large") ||
    text.includes("maximum context length") ||
    text.includes("context length exceeded")
  ) {
    const code = errorCode || "413";
    return {
      ...base,
      code,
      title: `ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞Í∞Ä ÎÑàÎ¨¥ ÌÅΩÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: ${code})`,
      guide:
        "Ìïú Î≤àÏóê Ï†ÑÏÜ°ÌïòÎäî ÌÖçÏä§Ìä∏ ÎòêÎäî ÎåÄÌôî Í∏∏Ïù¥Í∞Ä Î™®Îç∏Ïù¥ÎÇò ÏÑúÎ≤ÑÏóêÏÑú ÌóàÏö©ÌïòÎäî Î≤îÏúÑÎ•º ÎÑòÏóàÏäµÎãàÎã§.",
      hint:
        "ÏßàÎ¨∏/ÎåÄÌôîÎ•º Ïó¨Îü¨ Î≤àÏúºÎ°ú ÎÇòÎàÑÍ±∞ÎÇò, ÏïûÎ∂ÄÎ∂ÑÏùÑ ÏöîÏïΩÌï¥ÏÑú Î≥¥ÎÇ¥ Ï£ºÏÑ∏Ïöî. Î∂àÌïÑÏöîÌïú ÏÑ§Î™ÖÏùÑ Ï§ÑÏù¥Í≥† ÌïµÏã¨Îßå Ï†ÅÏúºÎ©¥ Îçî ÏïàÏ†ïÏ†ÅÏúºÎ°ú ÎèôÏûëÌï©ÎãàÎã§.",
    };
  }

  if (
    text.includes("Failed to fetch") ||
    text.includes("NetworkError") ||
    text.includes("ECONNREFUSED") ||
    text.includes("ENOTFOUND") ||
    text.includes("ERR_CONNECTION") ||
    text.toLowerCase().includes("timeout")
  ) {
    return {
      ...base,
      code: errorCode || "NETWORK",
      title: "ÏÑúÎ≤ÑÏôÄ ÌÜµÏã†ÌïòÎäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.",
      guide:
        "Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ ÏÉÅÌÉúÍ∞Ä Î∂àÏïàÏ†ïÌïòÍ±∞ÎÇò ÏÑúÎ≤ÑÏóê ÏùºÏãúÏ†ÅÏù∏ Î¨∏Ï†úÍ∞Ä ÏûàÏùÑ Ïàò ÏûàÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®Ìïú Îí§ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.",
      hint:
        "ÏôÄÏù¥ÌååÏù¥¬∑Ïú†ÏÑ† Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÍ≥†, ÌöåÏÇ¨/ÌïôÍµê ÎÑ§Ìä∏ÏõåÌÅ¨ÎùºÎ©¥ Î∞©ÌôîÎ≤ΩÏù¥ÎÇò VPN ÏÑ§Ï†ïÎèÑ Ìï®Íªò Ï†êÍ≤ÄÌï¥ Ï£ºÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "401" || text.includes("Unauthorized")) {
    return {
      ...base,
      code: errorCode || "401",
      title: "Ïù∏Ï¶ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 401)",
      guide:
        "ÌïÑÏöîÌïú API ÌÇ§ ÎòêÎäî Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÍ±∞ÎÇò ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§.",
      hint:
        "Î∞±ÏóîÎìú ÏÑúÎ≤ÑÏùò ÌôòÍ≤ΩÎ≥ÄÏàò(.env)Ïóê ÏÑ§Ï†ïÎêú API ÌÇ§Í∞Ä Ïò¨Î∞îÎ•∏ÏßÄ, ÎòêÎäî Î°úÍ∑∏Ïù∏ ÏÑ∏ÏÖòÏù¥ Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "403" || text.includes("Forbidden")) {
    return {
      ...base,
      code: errorCode || "403",
      title: "ÏöîÏ≤≠Ïóê ÎåÄÌïú Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 403)",
      guide:
        "Ìï¥Îãπ ÏûëÏóÖÏùÑ ÏàòÌñâÌï† Í∂åÌïúÏù¥ ÏóÜÎäî Í≥ÑÏ†ïÏúºÎ°ú ÏöîÏ≤≠ÌñàÍ±∞ÎÇò, Í∂åÌïú ÏÑ§Ï†ïÏù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§.",
      hint:
        "API ÎåÄÏãúÎ≥¥ÎìúÏùò Í∂åÌïú Î≤îÏúÑÎ•º ÌôïÏù∏ÌïòÍ±∞ÎÇò, Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Ï†ëÍ∑º Í∂åÌïúÏùÑ ÏöîÏ≤≠Ìï¥ Ï£ºÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "404" || text.includes("Not Found")) {
    return {
      ...base,
      code: errorCode || "404",
      title: "ÏöîÏ≤≠Ìïú Ï£ºÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 404)",
      guide:
        "Î∞±ÏóîÎìúÏùò /chat Í∞ôÏùÄ ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï£ºÏÜåÍ∞Ä ÏûòÎ™ªÎêòÏóàÍ±∞ÎÇò, ÏÑúÎ≤ÑÏóê Ìï¥Îãπ Í≤ΩÎ°úÍ∞Ä ÏóÜÏäµÎãàÎã§.",
      hint:
        "fetchÏóê ÏÇ¨Ïö©Ìïú URL(Ìè¨Ìä∏ Ìè¨Ìï®)Í≥º Flask ÎùºÏö∞Ìä∏(@app.route('/chat'))Í∞Ä Ï†ïÌôïÌûà ÏùºÏπòÌïòÎäîÏßÄ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "400" || text.includes("Bad Request")) {
    return {
      ...base,
      code: errorCode || "400",
      title: "ÏöîÏ≤≠ ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 400)",
      guide:
        "ÏÑúÎ≤ÑÍ∞Ä Ïù¥Ìï¥Ìï† Ïàò ÏóÜÎäî ÌòïÏãùÏùò Îç∞Ïù¥ÌÑ∞Î•º Î≥¥ÎÉàÏäµÎãàÎã§. JSON Íµ¨Ï°∞ÎÇò ÌïÑÏàò ÌïÑÎìúÍ∞Ä Îπ†Ï†∏ ÏûàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.",
      hint:
        "fetchÏóêÏÑú Ï†ÑÏÜ°ÌïòÎäî body(JSON.stringify Î∂ÄÎ∂Ñ)ÏôÄ ÏÑúÎ≤ÑÏóêÏÑú Í∏∞ÎåÄÌïòÎäî ÌïÑÎìú Ïù¥Î¶ÑÏù¥ ÏùºÏπòÌïòÎäîÏßÄ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "408") {
    return {
      ...base,
      code: "408",
      title: "ÏöîÏ≤≠ ÏãúÍ∞ÑÏù¥ ÎÑàÎ¨¥ Ïò§Îûò Í±∏Î¶ΩÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 408)",
      guide:
        "ÏÑúÎ≤ÑÍ∞Ä ÏßÄÏ†ïÎêú ÏãúÍ∞Ñ ÏïàÏóê ÏùëÎãµÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. ÏùºÏãúÏ†ÅÏù∏ ÏßÄÏó∞Ïùº Ïàò ÏûàÏäµÎãàÎã§.",
      hint:
        "Í∞ôÏùÄ ÏöîÏ≤≠ÏùÑ Ïó¨Îü¨ Î≤à Î∞òÎ≥µÌï¥ÏÑú Î≥¥ÎÇ¥ÏßÄ ÎßêÍ≥†, Ïû†Ïãú Í∏∞Îã§Î†∏Îã§Í∞Ä Îã§Ïãú ÏãúÎèÑÌï¥ Î≥¥ÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "413") {
    return {
      ...base,
      code: "413",
      title: "ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞Í∞Ä ÎÑàÎ¨¥ ÌÅΩÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 413)",
      guide:
        "Ìïú Î≤àÏóê Ï†ÑÏÜ°ÌïòÎäî ÌÖçÏä§Ìä∏ ÎòêÎäî ÌååÏùº ÌÅ¨Í∏∞Í∞Ä ÏÑúÎ≤ÑÏóêÏÑú ÌóàÏö©ÌïòÎäî Î≤îÏúÑÎ•º ÎÑòÏóàÏäµÎãàÎã§.",
      hint:
        "ÏßàÎ¨∏Ïù¥ÎÇò Ï≤®Î∂Ä Îç∞Ïù¥ÌÑ∞Î•º ÎÇòÎàÑÏñ¥ÏÑú Ïó¨Îü¨ Î≤àÏóê Í±∏Ï≥ê Ï†ÑÏÜ°Ìï¥ Ï£ºÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "429") {
    return {
      ...base,
      code: "429",
      title: "ÏöîÏ≤≠Ïù¥ ÎÑàÎ¨¥ ÏûêÏ£º Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 429)",
      guide:
        "ÏßßÏùÄ ÏãúÍ∞ÑÏóê ÎÑàÎ¨¥ ÎßéÏùÄ ÏöîÏ≤≠ÏùÑ Î≥¥ÎÇ¥ÏÑú ÏÑúÎ≤ÑÏùò Ï†úÌïúÏóê Í±∏Î†∏ÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.",
      hint: "ÏöîÏ≤≠ Í∞Ñ Í∞ÑÍ≤©ÏùÑ ÎäòÎ¶¨Í±∞ÎÇò, Íº≠ ÌïÑÏöîÌïú ÏöîÏ≤≠Îßå Î≥¥ÎÇ¥ÎèÑÎ°ù Ï°∞Ï†àÌï¥ Ï£ºÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "500" || text.includes("Internal Server Error")) {
    return {
      ...base,
      code: errorCode || "500",
      title: "ÏÑúÎ≤Ñ ÎÇ¥Î∂ÄÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 500)",
      guide:
        "Î∞±ÏóîÎìú ÏΩîÎìúÎÇò Ïô∏Î∂Ä APIÏóêÏÑú ÏòàÍ∏∞Ïπò Î™ªÌïú ÏòàÏô∏Í∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.",
      hint:
        "Í∞úÎ∞ú Ï§ëÏù¥ÎùºÎ©¥ ÏÑúÎ≤Ñ ÏΩòÏÜî Î°úÍ∑∏Î•º ÌôïÏù∏Ìï¥ Ïã§Ï†ú Ïä§ÌÉùÌä∏Î†àÏù¥Ïä§Î•º ÏÇ¥Ìé¥Î≥¥Îäî Í≤ÉÏù¥ Ï¢ãÏäµÎãàÎã§.",
    };
  }

  if (errorCode === "502") {
    return {
      ...base,
      code: "502",
      title: "Ï§ëÍ∞Ñ Í≤åÏù¥Ìä∏Ïõ®Ïù¥ ÏÑúÎ≤ÑÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 502)",
      guide:
        "Î∞±ÏóîÎìú ÏÑúÎ≤Ñ ÎòêÎäî Í∑∏ ÏïûÎã®Ïùò ÌîÑÎ°ùÏãú/Í≤åÏù¥Ìä∏Ïõ®Ïù¥Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏùëÎãµÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.",
      hint:
        "ÌÅ¥ÎùºÏö∞Îìú ÌôòÍ≤ΩÏù¥ÎùºÎ©¥ Î°úÎìúÎ∞∏Îü∞ÏÑú/ÌîÑÎ°ùÏãú ÏÑ§Ï†ïÍ≥º Î∞±ÏóîÎìú ÏÑúÎ≤Ñ ÏÉÅÌÉúÎ•º Ìï®Íªò Ï†êÍ≤ÄÌï¥ Ï£ºÏÑ∏Ïöî.",
    };
  }

  if (errorCode === "503") {
    return {
      ...base,
      code: "503",
      title: "ÏÑúÎ≤ÑÎ•º ÏùºÏãúÏ†ÅÏúºÎ°ú ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 503)",
      guide:
        "ÏÑúÎ≤ÑÍ∞Ä Ï†êÍ≤Ä Ï§ëÏù¥Í±∞ÎÇò Í≥ºÎ∂ÄÌïò ÏÉÅÌÉúÏùº Ïàò ÏûàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.",
      hint:
        "ÏßÄÏÜçÏ†ÅÏúºÎ°ú 503Ïù¥ Î∞úÏÉùÌïúÎã§Î©¥, ÏÑúÎ≤Ñ Ïù∏Ïä§ÌÑ¥Ïä§ ÏàòÎ•º ÎäòÎ¶¨Í±∞ÎÇò Ìä∏ÎûòÌîΩÏùÑ Î∂ÑÏÇ∞ÌïòÎäî Î∞©ÏïàÏùÑ Í≥†Î†§Ìï¥Ïïº Ìï©ÎãàÎã§.",
    };
  }

  if (errorCode === "504") {
    return {
      ...base,
      code: "504",
      title: "ÏÑúÎ≤Ñ ÏùëÎãµ ÏãúÍ∞ÑÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: 504)",
      guide:
        "Î∞±ÏóîÎìú ÏÑúÎ≤ÑÏóêÏÑú Ï≤òÎ¶¨ ÏãúÍ∞ÑÏù¥ ÎÑàÎ¨¥ Ïò§Îûò Í±∏Î†§ Í≤åÏù¥Ìä∏Ïõ®Ïù¥ÏóêÏÑú ÏöîÏ≤≠ÏùÑ Ï§ëÎã®ÌñàÏäµÎãàÎã§.",
      hint:
        "ÌäπÏ†ï ÏöîÏ≤≠ÏóêÏÑúÎßå Î∞òÎ≥µÎêúÎã§Î©¥, Ìï¥Îãπ ÏöîÏ≤≠Ïùò Ï≤òÎ¶¨ Î°úÏßÅÏùÑ ÏµúÏ†ÅÌôîÌïòÍ±∞ÎÇò ÌÉÄÏûÑÏïÑÏõÉ ÏãúÍ∞ÑÏùÑ Ï°∞Ï†ïÌï¥Ïïº Ìï©ÎãàÎã§.",
    };
  }

  return {
    ...base,
    title: errorCode
      ? `Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. (ÏóêÎü¨ ÏΩîÎìú: ${errorCode})`
      : "Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
    guide:
      "ÏÑúÎ≤ÑÏóêÏÑú ÏòàÍ∏∞Ïπò Î™ªÌïú Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÍ±∞ÎÇò, ÏßàÎ¨∏ ÎÇ¥Ïö©ÏùÑ Ï°∞Í∏à ÏàòÏ†ïÌï¥ÏÑú Î≥¥ÎÇ¥ Î≥¥ÏÑ∏Ïöî.",
    hint:
      "Í≥ÑÏÜç Í∞ôÏùÄ Ïò§Î•òÍ∞Ä Î∞òÎ≥µÎêúÎã§Î©¥, ÌôîÎ©¥Ïóê Î≥¥Ïù¥Îäî ÏóêÎü¨ ÏΩîÎìúÏôÄ Ìï®Íªò Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌï¥ Ï£ºÏÑ∏Ïöî.",
  };
}

// ---------------------------------------------------------
// Ïú†Ìã∏: Ï≤´ ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄÎ°ú ÏÇ¨Ïù¥ÎìúÎ∞î Ï†úÎ™© ÏöîÏïΩ
// ---------------------------------------------------------
function summarizeTitleFromMessages(messages) {
  const firstUser = messages.find((m) => m.role === "user");
  if (!firstUser || !firstUser.text) return "ÏÉà ÎåÄÌôî";
  const t = firstUser.text.trim();
  if (!t) return "ÏÉà ÎåÄÌôî";
  return t.length > 18 ? t.slice(0, 18) + "‚Ä¶" : t;
}

// ---------------------------------------------------------
// Ïú†Ìã∏: Î¶¨Ïä§Ìä∏ ÏûêÎèô Ïä§ÌÅ¨Î°§(ÎìúÎûòÍ∑∏ Ïãú ÏÉÅ/ÌïòÎã® Í∑ºÏ†ë Ïä§ÌÅ¨Î°§)
// ---------------------------------------------------------
function autoScroll(container, clientY) {
  if (!container) return;
  const rect = container.getBoundingClientRect();
  const margin = 36;
  const maxSpeed = 16;
  let dy = 0;

  if (clientY < rect.top + margin) {
    dy = -((rect.top + margin) - clientY) / (margin / maxSpeed);
  } else if (clientY > rect.bottom - margin) {
    dy = (clientY - (rect.bottom - margin)) / (margin / maxSpeed);
  }

  if (dy !== 0) {
    container.scrollTop += dy;
  }
}

// ---------------------------------------------------------
// Ïú†Ìã∏: DataTransferÏóêÏÑú Ï±ÑÌåÖ/Ìè¥Îçî ID ÏïàÏ†Ñ Ï∂îÏ∂ú
// ---------------------------------------------------------
function getDraggedChatId(e) {
  return (
    e.dataTransfer.getData("application/x-chat-id") ||
    e.dataTransfer.getData("text/x-chat-id") ||
    e.dataTransfer.getData("text/plain") ||
    ""
  );
}
function getDraggedFolderId(e) {
  return (
    e.dataTransfer.getData("application/x-folder-id") ||
    e.dataTransfer.getData("text/x-folder-id") ||
    e.dataTransfer.getData("text/plain") ||
    ""
  );
}

// =========================================================
// Ï±ÑÌåÖ ÌéòÏù¥ÏßÄ
// =========================================================
function ChatPage() {
  const navigate = useNavigate();
  const location = useLocation();
  const [foldersCollapsed] = useState(false);
  const [isOnline, setIsOnline] = useState(true);
  const [hoveredMessageIndex, setHoveredMessageIndex] = useState(null);
  const [openMessageMenuIndex, setOpenMessageMenuIndex] = useState(null);
  const [copyToastVisible, setCopyToastVisible] = useState(false);
  const [loadingPhase, setLoadingPhase] = useState(null);
  const phaseTimersRef = useRef([]); // ‚≠ê Î°úÎî© Îã®Í≥Ñ ÌÉÄÏù¥Î®∏ Ï†ÄÏû•Ïö©

  // ‚úÖ Ìè¥ÎçîÎ≥Ñ Ï†ëÌûò ÏÉÅÌÉú Í¥ÄÎ¶¨
  const [collapsedFolderIds, setCollapsedFolderIds] = useState(() => new Set());
  const isFolderCollapsed = (id) => collapsedFolderIds.has(id);
  const toggleFolder = (id) =>
    setCollapsedFolderIds((prev) => {
      const s = new Set(prev);
      if (s.has(id)) s.delete(id);
      else s.add(id);
      return s;
    });

  // ----------------------------- Îç∞Ïù¥ÌÑ∞/ÏÑ†ÌÉù/Î™®Îã¨/ÎìúÎûòÍ∑∏/ÏÇ¨Ïù¥ÎìúÎ∞î ÏÉÅÌÉú
  const [chatState, setChatState] = useState(getInitialChatState);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const [errorInfo, setErrorInfo] = useState(null);
  const [focusArea, setFocusArea] = useState("chat"); // 'chat' | 'folder'

  // üîç Ï±ÑÌåÖ Í≤ÄÏÉâ ÏÉÅÌÉú
  const [chatSearch, setChatSearch] = useState("");
  const [isSearchModalOpen, setIsSearchModalOpen] = useState(false);

  // ‚úÖ ÌòÑÏû¨ Ïñ¥Îñ§ Ï±ÑÌåÖÎ∞©Ïù¥ ÏùëÎãµ ÎåÄÍ∏∞ Ï§ëÏù∏ÏßÄ Ï∂îÏ†Å
  const [pendingConvId, setPendingConvId] = useState(null);

  // Ï±ÑÌåÖÏö© ÎçîÎ≥¥Í∏∞ Î©îÎâ¥
  const [menuOpenId, setMenuOpenId] = useState(null);
  const [menuPosition, setMenuPosition] = useState(null); // {x,y}
  const [menuInFolder, setMenuInFolder] = useState(false);

  // Ìè¥ÎçîÏö© ÎçîÎ≥¥Í∏∞ Î©îÎâ¥
  const [folderMenuOpenId, setFolderMenuOpenId] = useState(null);
  const [folderMenuPosition, setFolderMenuPosition] = useState(null);

  const [confirmDelete, setConfirmDelete] = useState(null); // {id, title}
  const [renameInfo, setRenameInfo] = useState(null); // {id, value}
  const [confirmFolderDelete, setConfirmFolderDelete] = useState(null);
  const [folderCreateModalOpen, setFolderCreateModalOpen] = useState(false);
  const [newFolderName, setNewFolderName] = useState("");
  const [folderRenameInfo, setFolderRenameInfo] = useState(null);
  const [pendingFolderConvId, setPendingFolderConvId] = useState(null);

  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);

  // ÏÑ†ÌÉùÎêú Ìè¥Îçî id
  const [selectedFolderId, setSelectedFolderId] = useState(null);

  // ÏÇ¨Ïù¥ÎìúÎ∞î Ìè≠ & Î¶¨ÏÇ¨Ïù¥Ï¶à ÏÉÅÌÉú
  const [sidebarWidth, setSidebarWidth] = useState(SIDEBAR_INIT_WIDTH);
  const [isResizingSidebar, setIsResizingSidebar] = useState(false);
  const sidebarResizeRef = useRef(null);

  // ÎìúÎûòÍ∑∏ ÏÉÅÌÉú
  const [draggingId, setDraggingId] = useState(null);
  const [dragOverId, setDragOverId] = useState(null);
  const [dragOverFolderId, setDragOverFolderId] = useState(null);
  const [folderDraggingId, setFolderDraggingId] = useState(null);
  const [folderDragOverId, setFolderDragOverId] = useState(null);

  const rootListRef = useRef(null);
  const folderChatsRefs = useRef({});

  const conversations = chatState.conversations || [];
  const folders = chatState.folders || [];
  const currentId = chatState.currentId;
  const currentConv =
    conversations.find((c) => c.id === currentId) || conversations[0];
  const messages = currentConv ? currentConv.messages : [];

  const isCurrentPending =
    loading && currentConv && pendingConvId && currentConv.id === pendingConvId;

  // ----------------------------- Ï†ÄÏû•
  useEffect(() => {
    try {
      const payload = { conversations, folders, currentId };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    } catch (e) {
      console.error("ÎåÄÌôî Î™©Î°ù Ï†ÄÏû• Ï§ë Ïò§Î•ò:", e);
    }
  }, [conversations, folders, currentId]);

  // ----------------------------- Ï±ÑÌåÖÏ∞Ω ÎÅùÏúºÎ°ú Ïä§ÌÅ¨Î°§
  const messagesEndRef = useRef(null);
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({
        behavior: "smooth",
        block: "end",
      });
    }
  }, [messages, pendingConvId]);

  // ----------------------------- Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Î°úÎî© ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
  useEffect(() => {
    return () => {
      phaseTimersRef.current.forEach((id) => clearTimeout(id));
      phaseTimersRef.current = [];
    };
  }, []);

  // ----------------------------- Îπà Í≥≥ ÌÅ¥Î¶≠ Ïãú ÎçîÎ≥¥Í∏∞ Î©îÎâ¥ Îã´Í∏∞
  useEffect(() => {
    const handleWindowClick = () => {
      setMenuOpenId(null);
      setFolderMenuOpenId(null);
      setOpenMessageMenuIndex(null);
    };
    window.addEventListener("click", handleWindowClick);
    return () => window.removeEventListener("click", handleWindowClick);
  }, []);

  // ----------------------------- Ï†ÑÏó≠ Îã®Ï∂ïÌÇ§: Ctrl/Cmd+K, Ctrl/Cmd+N
  useEffect(() => {
    const onGlobalHotkey = (e) => {
      const target = e.target;
      if (
        target &&
        (target.tagName === "INPUT" ||
          target.tagName === "TEXTAREA" ||
          target.isContentEditable)
      ) {
        return;
      }

      const isMac = navigator.platform.toLowerCase().includes("mac");
      const ctrlOrCmd = isMac ? e.metaKey : e.ctrlKey;
      if (!ctrlOrCmd) return;

      const key = e.key.toLowerCase();

      if (key === "k") {
        e.preventDefault();
        setChatSearch("");
        setIsSearchModalOpen(true);
      } else if (key === "n") {
        e.preventDefault();
        handleNewChat();
      }
    };

    window.addEventListener("keydown", onGlobalHotkey);
    return () => window.removeEventListener("keydown", onGlobalHotkey);
  }, []);

  // ----------------------------- online/offline
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);
    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);

  // ----------------------------- ESC / Enter Î™®Îã¨ Ï†úÏñ¥
  useEffect(() => {
    const onKey = (e) => {
      if (e.key === "Escape") {
        setConfirmDelete(null);
        setConfirmFolderDelete(null);
        setFolderCreateModalOpen(false);
        setFolderRenameInfo(null);
        setRenameInfo(null);
        setMenuOpenId(null);
        setFolderMenuOpenId(null);
        setIsSearchModalOpen(false);
        setOpenMessageMenuIndex(null);
        return;
      }
      if (e.key !== "Enter") return;

      if (confirmDelete) {
        e.preventDefault();
        handleDeleteConversation(confirmDelete.id);
        setConfirmDelete(null);
        return;
      }
      if (confirmFolderDelete) {
        e.preventDefault();
        handleDeleteFolder(confirmFolderDelete.id);
        setConfirmFolderDelete(null);
        return;
      }
      if (folderRenameInfo) {
        e.preventDefault();
        handleRenameFolderConfirm();
        return;
      }
      if (renameInfo) {
        e.preventDefault();
        handleRenameConversation(renameInfo.id, renameInfo.value);
        setRenameInfo(null);
        return;
      }
    };

    if (
      confirmDelete ||
      confirmFolderDelete ||
      folderRenameInfo ||
      folderRenameInfo?.value ||
      renameInfo ||
      renameInfo?.value ||
      menuOpenId ||
      folderMenuOpenId ||
      folderCreateModalOpen ||
      isSearchModalOpen
    ) {
      window.addEventListener("keydown", onKey);
      return () => window.removeEventListener("keydown", onKey);
    }
  }, [
    confirmDelete,
    confirmFolderDelete,
    folderRenameInfo,
    folderRenameInfo?.value,
    renameInfo,
    renameInfo?.value,
    menuOpenId,
    folderMenuOpenId,
    folderCreateModalOpen,
    isSearchModalOpen,
  ]);

  // ----------------------------- Delete ÌÇ§: focusArea
  useEffect(() => {
    const handleDeleteKey = (e) => {
      if (e.key !== "Delete") return;

      const active = document.activeElement;
      if (
        active &&
        (active.tagName === "INPUT" ||
          active.tagName === "TEXTAREA" ||
          active.isContentEditable)
      ) {
        return;
      }

      if (focusArea === "chat") {
        if (!currentConv) return;
        setConfirmDelete({ id: currentConv.id, title: currentConv.title });
        return;
      }

      if (focusArea === "folder") {
        if (selectedFolderId) {
          const folder = folders.find((f) => f.id === selectedFolderId);
          if (!folder) return;
          setConfirmFolderDelete({ id: folder.id, name: folder.name });
        }
        return;
      }

      if (selectedFolderId) {
        const folder = folders.find((f) => f.id === selectedFolderId);
        if (!folder) return;
        setConfirmFolderDelete({ id: folder.id, name: folder.name });
        return;
      }
      if (!currentConv) return;
      setConfirmDelete({ id: currentConv.id, title: currentConv.title });
    };

    window.addEventListener("keydown", handleDeleteKey);
    return () => window.removeEventListener("keydown", handleDeleteKey);
  }, [currentConv, selectedFolderId, folders, focusArea]);

  // ----------------------------- ÏÇ¨Ïù¥ÎìúÎ∞î ÎìúÎûòÍ∑∏ Î¶¨ÏÇ¨Ïù¥Ï¶à
  useEffect(() => {
    if (!isResizingSidebar) return;

    const handleMouseMove = (e) => {
      const data = sidebarResizeRef.current;
      if (!data) return;
      const delta = e.clientX - data.startX;
      let nextWidth = data.startWidth + delta;

      if (nextWidth < SIDEBAR_MIN_WIDTH) nextWidth = SIDEBAR_MIN_WIDTH;
      if (nextWidth > SIDEBAR_MAX_WIDTH) nextWidth = SIDEBAR_MAX_WIDTH;
      setSidebarWidth(nextWidth);
    };

    const handleMouseUp = () => {
      setIsResizingSidebar(false);
      sidebarResizeRef.current = null;
    };

    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
  }, [isResizingSidebar]);

  const handleSidebarResizeMouseDown = (e) => {
    if (sidebarCollapsed) return;
    e.preventDefault();
    sidebarResizeRef.current = { startX: e.clientX, startWidth: sidebarWidth };
    setIsResizingSidebar(true);
  };

  // ----------------------------- ÏÉà Ï±ÑÌåÖ
  const handleNewChat = () => {
    const newConv = createNewConversation();
    setChatState((prev) => {
      const prevList = prev.conversations || [];
      const newList = [...prevList, newConv];
      return { ...prev, conversations: newList, currentId: newConv.id };
    });
    setSelectedFolderId(null);
    setErrorInfo(null);
    setInput("");
    setMenuOpenId(null);
    setFolderMenuOpenId(null);
    setFocusArea("chat");
    setChatSearch("");
  };

  const startedFromHomeRef = useRef(false);

  // Ìôà ‚Üí Ï±ÑÌåÖ ÏãúÏûë ÌïòÍ∏∞
  useEffect(() => {
    if (!location?.state?.newChat) return;
    if (startedFromHomeRef.current) return;
    startedFromHomeRef.current = true;

    handleNewChat();
    navigate("/chat", { replace: true });
  }, [location?.state?.newChat, navigate]);

  // ----------------------------- ÎåÄÌôî ÏÑ†ÌÉù/ÏÇ≠Ï†ú/Ïù¥Î¶ÑÎ≥ÄÍ≤Ω
  const handleSelectConversation = (id) => {
    setChatState((prev) => ({ ...prev, currentId: id }));
    setSelectedFolderId(null);
    setErrorInfo(null);
    setInput("");
    setMenuOpenId(null);
    setFolderMenuOpenId(null);
    setFocusArea("chat");
    setIsSearchModalOpen(false);
  };

  const handleDeleteConversation = (id) => {
    setChatState((prev) => {
      const list = prev.conversations || [];
      const deleteIndex = list.findIndex((c) => c.id === id);
      let filtered = list.filter((c) => c.id !== id);
      let newCurrentId = prev.currentId;

      if (filtered.length === 0) {
        const newConv = createNewConversation();
        filtered = [newConv];
        newCurrentId = newConv.id;
      } else if (prev.currentId === id) {
        const samePosIndex =
          deleteIndex >= 0 && deleteIndex < filtered.length
            ? deleteIndex
            : filtered.length - 1;
        newCurrentId = filtered[samePosIndex].id;
      }
      return { ...prev, conversations: filtered, currentId: newCurrentId };
    });

    if (id === pendingConvId) {
      setPendingConvId(null);
      setLoading(false);
    }

    setMenuOpenId(null);
    setFolderMenuOpenId(null);
    setFocusArea("chat");
  };

  const handleRenameConversation = (id, newTitle) => {
    const trimmed = (newTitle || "").trim();
    if (!trimmed) return;

    setChatState((prev) => ({
      ...prev,
      conversations: (prev.conversations || []).map((c) =>
        c.id === id ? { ...c, title: trimmed, updatedAt: Date.now() } : c
      ),
    }));
    setMenuOpenId(null);
    setFolderMenuOpenId(null);
  };

  const openDeleteConfirmModal = (id, title) => {
    setConfirmDelete({ id, title });
    setMenuOpenId(null);
    setFolderMenuOpenId(null);
    setFocusArea("chat");
  };

  const openFolderDeleteConfirmModal = (id, name) => {
    setConfirmFolderDelete({ id, name });
    setFolderMenuOpenId(null);
    setMenuOpenId(null);
    setFocusArea("folder");
  };

  const openRenameModal = (id, title) => {
    setRenameInfo({ id, value: title || "" });
    setMenuOpenId(null);
    setFolderMenuOpenId(null);
    setFocusArea("chat");
  };

  // ----------------------------- Ìè¥Îçî ÏÉùÏÑ±/Ïù¥Î¶ÑÎ≥ÄÍ≤Ω/ÏÇ≠Ï†ú
  const handleCreateFolder = () => {
    setNewFolderName("");
    setFolderCreateModalOpen(true);
    setPendingFolderConvId(null);
    setFocusArea("folder");
  };

  const handleCreateFolderConfirm = () => {
    const trimmed = (newFolderName || "").trim();
    if (!trimmed) return;

    const now = Date.now();
    const folderId = String(now);
    const newFolder = { id: folderId, name: trimmed, createdAt: now };

    setChatState((prev) => {
      const nextFolders = [...(prev.folders || []), newFolder];
      let nextConversations = prev.conversations || [];

      if (pendingFolderConvId) {
        nextConversations = nextConversations.map((c) =>
          c.id === pendingFolderConvId ? { ...c, folderId } : c
        );
      }
      return { ...prev, folders: nextFolders, conversations: nextConversations };
    });
    setFolderCreateModalOpen(false);
    setNewFolderName("");
    setPendingFolderConvId(null);
  };

  const handleRenameFolder = (folderId) => {
    const target = folders.find((f) => f.id === folderId);
    setFolderRenameInfo({ id: folderId, value: target?.name || "" });
    setFolderMenuOpenId(null);
    setMenuOpenId(null);
  };

  const handleRenameFolderConfirm = () => {
    if (!folderRenameInfo) return;
    const trimmed = (folderRenameInfo.value || "").trim();
    if (!trimmed) return;

    setChatState((prev) => ({
      ...prev,
      folders: (prev.folders || []).map((f) =>
        f.id === folderRenameInfo.id ? { ...f, name: trimmed } : f
      ),
    }));
    setFolderRenameInfo(null);
  };

  // Ìè¥Îçî ÏÇ≠Ï†ú (ÏïàÏùò Ï±ÑÌåÖÏùÄ Î£®Ìä∏Î°ú Ïù¥Îèô)
  const handleDeleteFolder = (folderId) => {
    setChatState((prev) => {
      const list = prev.folders || [];
      const filtered = list.filter((f) => f.id !== folderId);

      return {
        ...prev,
        folders: filtered,
        conversations: (prev.conversations || []).map((c) =>
          c.folderId === folderId ? { ...c, folderId: null } : c
        ),
      };
    });

    setSelectedFolderId((prevSelectedId) => {
      if (prevSelectedId !== folderId) return prevSelectedId;
      const remaining = (folders || []).filter((f) => f.id !== folderId);
      return remaining.length ? remaining[0].id : null;
    });

    setFocusArea("folder");
  };

  // ----------------------------- Ìè¥Îçî ÎìúÎûòÍ∑∏ Í¥ÄÎ†®
  const handleFolderDragOver = (e, folderId) => {
    e.preventDefault();
    if (folderDraggingId) {
      setFolderDragOverId(folderId);
    } else {
      setDragOverFolderId(folderId);
    }

    const el = folderChatsRefs.current[folderId];
    if (el) autoScroll(el, e.clientY);
  };

  const handleDropChatOnFolderHeader = (e, folderId) => {
    e.preventDefault();
    e.stopPropagation();
    const convId = draggingId || getDraggedChatId(e);
    if (!convId) return;

    setChatState((prev) => ({
      ...prev,
      conversations: (prev.conversations || []).map((c) =>
        c.id === convId ? { ...c, folderId } : c
      ),
    }));
    setDraggingId(null);
    setDragOverId(null);
    setDragOverFolderId(null);
  };

  const handleFolderDrop = (e, folderId) => {
    e.preventDefault();
    e.stopPropagation();

    const draggedFolderId = folderDraggingId || getDraggedFolderId(e);
    if (draggedFolderId) {
      setChatState((prev) => {
        const list = [...(prev.folders || [])];
        const fromIndex = list.findIndex((f) => f.id === draggedFolderId);
        const toIndex = list.findIndex((f) => f.id === folderId);
        if (fromIndex === -1 || toIndex === -1 || fromIndex === toIndex) return prev;

        const [moved] = list.splice(fromIndex, 1);
        list.splice(toIndex, 0, moved);
        return { ...prev, folders: list };
      });

      setFolderDraggingId(null);
      setFolderDragOverId(null);
      setDragOverFolderId(null);
      return;
    }

    const convId = draggingId || getDraggedChatId(e);
    if (!convId) {
      setDraggingId(null);
      setDragOverId(null);
      setDragOverFolderId(null);
      return;
    }

    setChatState((prev) => {
      const exist = (prev.conversations || []).some((c) => c.id === convId);
      if (!exist) return prev;

      const nextConversations = (prev.conversations || []).map((c) =>
        c.id === convId ? { ...c, folderId } : c
      );
      return { ...prev, conversations: nextConversations };
    });

    setDraggingId(null);
    setDragOverId(null);
    setDragOverFolderId(null);
  };

  const handleMoveConversationToRoot = (id) => {
    setChatState((prev) => ({
      ...prev,
      conversations: (prev.conversations || []).map((c) =>
        c.id === id ? { ...c, folderId: null } : c
      ),
    }));
    setMenuOpenId(null);
    setFolderMenuOpenId(null);
    setFocusArea("chat");
  };

  const handleFolderItemDragStart = (e, folderId) => {
    setFolderDraggingId(folderId);
    setSelectedFolderId(folderId);
    setFolderDragOverId(null);
    setDragOverFolderId(null);
    setDraggingId(null);
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("application/x-folder-id", folderId);
    e.dataTransfer.setData("text/plain", folderId);
  };
  const handleFolderItemDragEnd = () => {
    setFolderDraggingId(null);
    setFolderDragOverId(null);
    setDragOverFolderId(null);
  };

  // ----------------------------- Ï±ÑÌåÖ ÎìúÎûòÍ∑∏
  const handleDragStart = (e, id) => {
    setDraggingId(id);
    setDragOverId(null);
    setDragOverFolderId(null);
    setFolderDraggingId(null);
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("application/x-chat-id", id);
    e.dataTransfer.setData("text/x-chat-id", id);
    e.dataTransfer.setData("text/plain", id);
  };
  const handleDragOver = (e, id) => {
    e.preventDefault();
    if (id !== dragOverId) setDragOverId(id);
  };

  const handleDropOnRootItem = (e, targetConvId) => {
    e.preventDefault();
    e.stopPropagation();

    const candidate = draggingId || getDraggedChatId(e);
    if (
      !candidate ||
      candidate === targetConvId ||
      !(conversations || []).some((c) => c.id === candidate)
    ) {
      setDraggingId(null);
      setDragOverId(null);
      setDragOverFolderId(null);
      return;
    }

    const rect = e.currentTarget.getBoundingClientRect();
    const centerY = rect.top + rect.height / 2;
    const insertAfter = e.clientY > centerY;

    setChatState((prev) => {
      const list = [...(prev.conversations || [])];
      const fromIndex = list.findIndex((c) => c.id === candidate);
      let toIndex = list.findIndex((c) => c.id === targetConvId);
      if (fromIndex === -1 || toIndex === -1) return prev;

      const [movedRaw] = list.splice(fromIndex, 1);
      const moved =
        movedRaw.folderId !== null ? { ...movedRaw, folderId: null } : movedRaw;

      if (fromIndex < toIndex) {
        toIndex -= 1;
      }

      let insertIndex = insertAfter ? toIndex + 1 : toIndex;

      if (insertIndex < 0) insertIndex = 0;
      if (insertIndex > list.length) insertIndex = list.length;

      list.splice(insertIndex, 0, moved);
      return { ...prev, conversations: list };
    });

    setDraggingId(null);
    setDragOverId(null);
    setDragOverFolderId(null);
  };

  const handleDropOnFolderChat = (e, targetConvId, folderId) => {
    e.preventDefault();
    e.stopPropagation();

    const candidate = draggingId || getDraggedChatId(e);
    if (
      !candidate ||
      candidate === targetConvId ||
      !(conversations || []).some((c) => c.id === candidate)
    ) {
      setDraggingId(null);
      setDragOverId(null);
      setDragOverFolderId(null);
      return;
    }

    setChatState((prev) => {
      const list = [...(prev.conversations || [])];
      const fromIndex = list.findIndex((c) => c.id === candidate);
      const toIndex = list.findIndex((c) => c.id === targetConvId);
      if (fromIndex === -1 || toIndex === -1) return prev;

      const [movedRaw] = list.splice(fromIndex, 1);
      const moved = { ...movedRaw, folderId };

      const newToIndex = list.findIndex((c) => c.id === targetConvId);
      const insertIndex = newToIndex === -1 ? list.length : newToIndex;

      list.splice(insertIndex, 0, moved);
      return { ...prev, conversations: list };
    });

    setDraggingId(null);
    setDragOverId(null);
    setDragOverFolderId(null);
  };

  const handleFolderChatsDragOver = (e, folderId) => {
    e.preventDefault();
    setDragOverFolderId(folderId);
    const el = folderChatsRefs.current[folderId];
    if (el) autoScroll(el, e.clientY);
  };

  const handleRootListDragOver = (e) => {
    e.preventDefault();
    setDragOverFolderId(null);
    if (rootListRef.current) autoScroll(rootListRef.current, e.clientY);
  };

  const handleRootListDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();

    if (folderDraggingId) {
      setFolderDraggingId(null);
      setFolderDragOverId(null);
      setDragOverFolderId(null);
      setDraggingId(null);
      setDragOverId(null);
      return;
    }

    const candidate = draggingId || getDraggedChatId(e);
    if (!candidate || !(conversations || []).some((c) => c.id === candidate)) {
      setDraggingId(null);
      setDragOverId(null);
      setDragOverFolderId(null);
      return;
    }

    let targetId = null;
    const container = rootListRef.current;
    if (container) {
      const items = Array.from(
        container.querySelectorAll(".sidebar-chat-item")
      );
      if (items.length > 0) {
        const mouseY = e.clientY;
        let nearestId = null;
        let nearestDist = Infinity;

        items.forEach((el) => {
          const rect = el.getBoundingClientRect();
          const centerY = rect.top + rect.height / 2;
          const dist = Math.abs(mouseY - centerY);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestId = el.dataset.chatId;
          }
        });

        targetId = nearestId;
      }
    }

    setChatState((prev) => {
      const list = [...(prev.conversations || [])];
      const fromIndex = list.findIndex((c) => c.id === candidate);
      if (fromIndex === -1) return prev;

      const [movedRaw] = list.splice(fromIndex, 1);
      const moved =
        movedRaw.folderId !== null ? { ...movedRaw, folderId: null } : movedRaw;

      if (!targetId) {
        list.push(moved);
      } else {
        const toIndex = list.findIndex((c) => c.id === targetId);
        if (toIndex === -1) {
          list.push(moved);
        } else {
          let insertIndex = toIndex;
          if (container) {
            const targetEl = container.querySelector(
              `.sidebar-chat-item[data-chat-id="${targetId}"]`
            );
            if (targetEl) {
              const rect = targetEl.getBoundingClientRect();
              const centerY = rect.top + rect.height / 2;
              if (e.clientY > centerY) {
                insertIndex = toIndex + 1;
              }
            }
          }
          list.splice(insertIndex, 0, moved);
        }
      }

      return { ...prev, conversations: list };
    });

    setDraggingId(null);
    setDragOverId(null);
    setDragOverFolderId(null);
  };

  const handleDragEnd = () => {
    setDraggingId(null);
    setDragOverId(null);
    setDragOverFolderId(null);
    setFolderDraggingId(null);
    setFolderDragOverId(null);
  };

  // ----------------------------- Î©îÏãúÏßÄ Î≥µÏÇ¨
  const handleCopyMessage = (text) => {
    if (!navigator.clipboard) {
      alert("ÌÅ¥Î¶ΩÎ≥¥Îìú Î≥µÏÇ¨Î•º ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Î∏åÎùºÏö∞Ï†ÄÏûÖÎãàÎã§.");
      return;
    }

    navigator.clipboard
      .writeText(text)
      .then(() => {
        setCopyToastVisible(false);
        requestAnimationFrame(() => {
          setCopyToastVisible(true);
        });
      })
      .catch(() => {
        alert("Î≥µÏÇ¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.");
      });
  };

  // ----------------------------- Î©îÏãúÏßÄ Ï†ÑÏÜ°
  const sendMessage = async () => {
    const trimmed = input.trim();
    if (!trimmed || loading || !currentConv) return;

    if (!navigator.onLine) {
      setIsOnline(false);
      setErrorInfo(makeErrorInfo("Network is offline"));
      return;
    }

    const targetConvId = currentConv.id;

    setErrorInfo(null);
    setInput("");
    setLoading(true);
    setPendingConvId(targetConvId);
    setMenuOpenId(null);
    setFolderMenuOpenId(null);

    // ‚≠ê Ïù¥Ï†Ñ Îã®Í≥Ñ ÌÉÄÏù¥Î®∏ Î™®Îëê Ï¥àÍ∏∞Ìôî
    phaseTimersRef.current.forEach((id) => clearTimeout(id));
    phaseTimersRef.current = [];

    // ‚≠ê Îã®Í≥ÑÎ≥Ñ ÌÖçÏä§Ìä∏ Î≥ÄÍ≤Ω: understanding ‚Üí searching ‚Üí composing
    setLoadingPhase("understanding");
    const t1 = setTimeout(() => {
      setLoadingPhase((prev) =>
        prev === "understanding" ? "searching" : prev
      );
    }, 900);
    const t2 = setTimeout(() => {
      setLoadingPhase((prev) =>
        prev === "searching" ? "composing" : prev
      );
    }, 1800);
    phaseTimersRef.current.push(t1, t2);

    setChatState((prev) => {
      const now = Date.now();
      const updated = (prev.conversations || []).map((conv) => {
        if (conv.id !== targetConvId) return conv;

        const newMessages = [...conv.messages, { role: "user", text: trimmed }];

        const hasUserBefore = conv.messages.some((m) => m.role === "user");
        const newTitle = hasUserBefore
          ? conv.title
          : summarizeTitleFromMessages(newMessages);

        return { ...conv, messages: newMessages, updatedAt: now, title: newTitle };
      });
      return { ...prev, conversations: updated };
    });

    try {
      const res = await fetch(`${API_BASE}/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: trimmed }),
      });

      setIsOnline(true);

      const data = await res.json();
      if (data.error) {
        const info = makeErrorInfo(data.error);

        setChatState((prev) => {
          const now = Date.now();
          const updated = (prev.conversations || []).map((conv) => {
            if (conv.id !== targetConvId) return conv;
            const newMessages = [
              ...conv.messages,
              {
                role: "bot",
                text:
                  "Ï£ÑÏÜ°Ìï©ÎãàÎã§. Ïò§Î•ò ÎïåÎ¨∏Ïóê ÏßÄÍ∏àÏùÄ ÎãµÎ≥ÄÏùÑ ÏÉùÏÑ±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. ÌôîÎ©¥ Í∞ÄÏö¥Îç∞ ÎÇòÌÉÄÎÇú Ïò§Î•ò ÏïàÎÇ¥ Ï∞ΩÏùÑ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.",
              },
            ];
            return { ...conv, messages: newMessages, updatedAt: now };
          });
          return { ...prev, conversations: updated };
        });

        setErrorInfo(info);
      } else {
        const answer = data.answer || "(ÏùëÎãµÏù¥ ÏóÜÏäµÎãàÎã§)";
        // Ïù¥ÎØ∏ composing Îã®Í≥ÑÎ°ú Ïò¨ÎùºÍ∞Ñ ÏÉÅÌÉúÏùº Ïàò ÏûàÏúºÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî Îã®ÏàúÌûà Î©îÏãúÏßÄÎßå Ï∂îÍ∞Ä
        setChatState((prev) => {
          const now = Date.now();
          const updated = (prev.conversations || []).map((conv) => {
            if (conv.id !== targetConvId) return conv;
            const newMessages = [...conv.messages, { role: "bot", text: answer }];
            return { ...conv, messages: newMessages, updatedAt: now };
          });
          return { ...prev, conversations: updated };
        });
      }
    } catch (err) {
      setIsOnline(false);

      const info = makeErrorInfo(err?.message || err);

      setChatState((prev) => {
        const now = Date.now();
        const updated = (prev.conversations || []).map((conv) => {
          if (conv.id !== targetConvId) return conv;
          const newMessages = [
            ...conv.messages,
            {
              role: "bot",
              text:
                "ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÌôîÎ©¥ Í∞ÄÏö¥Îç∞ Ïò§Î•ò ÏïàÎÇ¥ Ï∞ΩÏùÑ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.",
            },
          ];
          return { ...conv, messages: newMessages, updatedAt: now };
        });
        return { ...prev, conversations: updated };
      });
      setErrorInfo(info);
    } finally {
      setLoading(false);
      setPendingConvId(null);
      // ‚≠ê ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨ + Îã®Í≥Ñ Ï¥àÍ∏∞Ìôî
      phaseTimersRef.current.forEach((id) => clearTimeout(id));
      phaseTimersRef.current = [];
      setLoadingPhase(null);
    }
  };

  const handleInputKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  const openErrorDetailWindow = () => {
    if (!errorInfo) return;
    try {
      const win = window.open("", "_blank", "width=720,height=600,scrollbars=yes");
      if (!win) {
        alert("ÌåùÏóÖ Ï∞®Îã®ÏúºÎ°ú Ïù∏Ìï¥ ÏÉàÎ°úÏö¥ Ï∞ΩÏùÑ Ïó¥ Ïàò ÏóÜÏäµÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÌåùÏóÖ ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.");
        return;
      }
      const escapeHtml = (str) =>
        String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

      win.document.write(`<!DOCTYPE html>
<html lang="ko"><head><meta charset="utf-8" />
<title>Ïò§Î•ò ÏÉÅÏÑ∏ Ï†ïÎ≥¥</title>
<style>
body{font-family:-apple-system,BlinkMacSystemFont,'Noto Sans KR',sans-serif;padding:16px;white-space:pre-wrap;background:#fff;color:#222}
h1{font-size:18px;margin-bottom:8px}h2{font-size:14px;margin:16px 0 4px}
pre{font-size:12px;background:#f7f7f7;padding:12px;border-radius:8px;max-height:420px;overflow:auto;white-space:pre-wrap;word-break:break-all}
</style></head>
<body>
<h1>${escapeHtml(errorInfo.title)}</h1>
<p>${escapeHtml(errorInfo.guide)}</p>
<p style="color:#666;">${escapeHtml(errorInfo.hint)}</p>
<h2>ÏõêÎ≥∏ Ïò§Î•ò Î©îÏãúÏßÄ</h2>
<pre>${escapeHtml(errorInfo.detail)}</pre>
</body></html>`);
      win.document.close();
    } catch (e) {
      console.error("Ïò§Î•ò ÏÉÅÏÑ∏ Ï∞Ω ÏÉùÏÑ± Ï§ë Ïò§Î•ò:", e);
    }
  };

  const rootConversations = conversations.filter((c) => !c.folderId);

  const modalSearchResults = chatSearch.trim()
    ? conversations.filter((conv) =>
        conv.title.toLowerCase().includes(chatSearch.toLowerCase())
      )
    : [];

  const activeMenuConversation = menuOpenId
    ? conversations.find((c) => c.id === menuOpenId)
    : null;
  const activeMenuFolder = folderMenuOpenId
    ? folders.find((f) => f.id === folderMenuOpenId)
    : null;

  // ------------------------------------------------------- Î†åÎçîÎßÅ
  return (
    <div className="page chat-page">
      {/* Í≤ÄÏÉâ Î™®Îã¨ + Î°úÎî©/Î≥µÏÇ¨ Î™®Îã¨ Ï†ÑÏö© Ïä§ÌÉÄÏùº */}
      <style>{`
        .sidebar-search-trigger {
          width: calc(100% - 24px);
          margin: 0 12px 12px 12px;
          padding: 10px;
          border: 1px dashed #ccc;
          border-radius: 8px;
          background-color: transparent;
          color: #666;
          font-size: 14px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.2s;
        }
        .sidebar-search-trigger:hover {
          background-color: #f9f9f9;
          border-color: #bbb;
          color: #333;
        }
        .sidebar-search-trigger svg {
          margin-right: 6px;
          opacity: 0.6;
        }
        .search-modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: rgba(0, 0, 0, 0.4);
          backdrop-filter: blur(2px);
          z-index: 9999;
          display: flex;
          justify-content: center;
          align-items: flex-start;
          padding-top: 120px;
        }
        .search-modal-content {
          width: 600px;
          max-width: 90%;
          background: #fff;
          border-radius: 12px;
          box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
          overflow: hidden;
          animation: fadeIn 0.2s ease-out;
        }
        .search-modal-header {
          padding: 16px;
          border-bottom: 1px solid #f0f0f0;
          display: flex;
          align-items: center;
        }
        .search-modal-input {
          flex: 1;
          border: none;
          font-size: 16px;
          outline: none;
          padding: 4px;
        }
        .search-modal-close {
          background: none;
          border: none;
          font-size: 20px;
          color: #999;
          cursor: pointer;
          padding: 0 8px;
        }
        .search-modal-results {
          max-height: 400px;
          overflow-y: auto;
          padding: 8px 0;
        }
        .search-result-item {
          padding: 12px 20px;
          cursor: pointer;
          display: flex;
          align-items: center;
          transition: background 0.15s;
        }
        .search-result-item:hover {
          background: #f3f4f6;
        }
        .search-result-icon {
          margin-right: 12px;
          color: #9ca3af;
        }
        .search-result-text {
          font-size: 14px;
          color: #374151;
        }
        .search-empty-state {
          padding: 32px;
          text-align: center;
          color: #9ca3af;
          font-size: 14px;
        }
        @keyframes fadeIn {
          from { opacity: 0; transform: translateY(-10px); }
          to { opacity: 1; transform: translateY(0); }
        }

        /* typing dots (Î°úÎî©Ï§ë ... Ïï†ÎãàÎ©îÏù¥ÏÖò) */
        .typing-dots {
          display: inline-flex;
          align-items: center;
          gap: 3px;
        }
        .typing-dots .dot {
          width: 4px;
          height: 4px;
          border-radius: 999px;
          background: currentColor;
          opacity: 0.4;
          animation: typingDots 1s infinite ease-in-out;
        }
        .typing-dots .dot:nth-child(2) {
          animation-delay: 0.15s;
        }
        .typing-dots .dot:nth-child(3) {
          animation-delay: 0.3s;
        }
        @keyframes typingDots {
          0%, 80%, 100% {
            transform: translateY(0);
            opacity: 0.4;
          }
          40% {
            transform: translateY(-2px);
            opacity: 1;
          }
        }
        .sidebar-chat-pending {
          font-size: 11px;
          color: #9ca3af;
        }

        /* Î≥µÏÇ¨ ÏôÑÎ£å Î™®Îã¨ (Í∞ÄÏö¥Îç∞) */
        .copy-modal-overlay {
          position: fixed;
          inset: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          background: rgba(0, 0, 0, 0.35);
          z-index: 10000;
        }
        .copy-modal {
          background: #ffffff;
          border-radius: 12px;
          padding: 20px 24px 16px;
          min-width: 220px;
          max-width: 280px;
          text-align: center;
          box-shadow:
            0 20px 25px -5px rgba(0, 0, 0, 0.1),
            0 10px 10px -5px rgba(0, 0, 0, 0.04);
          animation: copyModalFadeIn 0.2s ease-out;
        }
        .copy-modal-body {
          font-size: 14px;
          color: #111827;
          margin-bottom: 16px;
        }
        .copy-modal-footer {
          display: flex;
          justify-content: center;
        }
        .copy-modal-button {
          padding: 6px 18px;
          border-radius: 999px;
          border: none;
          background: #2563eb;
          color: #ffffff;
          font-size: 13px;
          cursor: pointer;
        }
        .copy-modal-button:hover {
          background: #1d4ed8;
        }
        @keyframes copyModalFadeIn {
          from {
            opacity: 0;
            transform: translateY(4px) scale(0.98);
          }
          to {
            opacity: 1;
            transform: translateY(0) scale(1);
          }
        }
      `}</style>

      {/* Î™®Î∞îÏùºÏö© ÏÇ¨Ïù¥ÎìúÎ∞î ÌÜ†Í∏Ä Î≤ÑÌäº */}
      <button
        className="sidebar-toggle-btn"
        onClick={(e) => {
          e.stopPropagation();
          setSidebarOpen((prev) => !prev);
        }}
        aria-label="ÏÇ¨Ïù¥ÎìúÎ∞î ÌÜ†Í∏Ä"
      ></button>

      <div className="chat-layout">
        {/* ===== Ï¢åÏ∏°: ÏÇ¨Ïù¥ÎìúÎ∞î ===== */}
        <aside
          className={
            "chat-sidebar" +
            (sidebarCollapsed ? " collapsed" : "") +
            (sidebarOpen ? " open" : "")
          }
          style={!sidebarCollapsed ? { flex: `0 0 ${sidebarWidth}px` } : undefined}
        >
          <div className="sidebar-top">
            <button
              className="sidebar-menu-toggle"
              onClick={() => setSidebarCollapsed((prev) => !prev)}
              aria-label={sidebarCollapsed ? "ÏÇ¨Ïù¥ÎìúÎ∞î ÌéºÏπòÍ∏∞" : "ÏÇ¨Ïù¥ÎìúÎ∞î Ï†ëÍ∏∞"}
            >
              <img src="/img/menu.png" alt="ÏÇ¨Ïù¥ÎìúÎ∞î Ï†ëÍ∏∞" />
            </button>

            {!sidebarCollapsed && (
              <button className="sidebar-new-chat-btn" onClick={handleNewChat}>
                ÏÉà Ï±ÑÌåÖ
              </button>
            )}
          </div>

          {!sidebarCollapsed && (
            <>
              {/* Ï±ÑÌåÖ Í≤ÄÏÉâ Ìä∏Î¶¨Í±∞ Î≤ÑÌäº */}
              <button
                className="sidebar-search-trigger"
                onClick={() => {
                  setChatSearch("");
                  setIsSearchModalOpen(true);
                }}
              >
                <svg
                  width="14"
                  height="14"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <circle cx="11" cy="11" r="8"></circle>
                  <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                Ï±ÑÌåÖ Í≤ÄÏÉâ
              </button>

              {/* ================== Ìè¥Îçî ÏÑπÏÖò ================== */}
              <div className="sidebar-section-title">Ìè¥Îçî</div>

              <div
                className="sidebar-folder-list"
                onMouseDown={() => setFocusArea("folder")}
              >
                {folders.length === 0 ? (
                  <div
                    className="sidebar-folder-empty"
                    onDragOver={(e) => e.preventDefault()}
                    onDrop={(e) => {
                      e.preventDefault();
                      const convId = draggingId || getDraggedChatId(e);
                      if (!convId) return;
                      setPendingFolderConvId(convId);
                      setFolderCreateModalOpen(true);
                    }}
                  >
                    Ìè¥ÎçîÍ∞Ä ÏóÜÏäµÎãàÎã§.
                  </div>
                ) : (
                  folders.map((folder) => {
                    const childConvs = conversations.filter(
                      (c) => c.folderId === folder.id
                    );
                    const isDropChat =
                      dragOverFolderId === folder.id && !folderDraggingId;
                    const isDragOverFolderSort =
                      folderDragOverId === folder.id && !!folderDraggingId;

                    const collapsed = isFolderCollapsed(folder.id);

                    return (
                      <div
                        key={folder.id}
                        className={
                          "sidebar-folder-item" +
                          (selectedFolderId === folder.id ? " selected" : "") +
                          (folderDraggingId === folder.id ? " dragging" : "") +
                          (isDragOverFolderSort ? " drag-over" : "") +
                          (isDropChat ? " drop-chat" : "") +
                          (collapsed ? " collapsed" : "")
                        }
                        draggable
                        onDragStart={(e) => handleFolderItemDragStart(e, folder.id)}
                        onDragOver={(e) => handleFolderDragOver(e, folder.id)}
                        onDrop={(e) => handleFolderDrop(e, folder.id)}
                        onDragEnd={handleFolderItemDragEnd}
                        onClick={() => setSelectedFolderId(folder.id)}
                        aria-label={`Ìè¥Îçî ${folder.name}`}
                      >
                        <div
                          className="sidebar-folder-header"
                          onMouseDown={(e) => {
                            e.stopPropagation();
                            setFocusArea("folder");
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSelectedFolderId(folder.id);
                          }}
                          onDragOver={(e) => {
                            e.preventDefault();
                            if (folderDraggingId || getDraggedFolderId(e)) {
                              setFolderDragOverId(folder.id);
                            } else {
                              setDragOverFolderId(folder.id);
                            }
                          }}
                          onDrop={(e) => {
                            if (folderDraggingId || getDraggedFolderId(e)) {
                              handleFolderDrop(e, folder.id);
                            } else {
                              handleDropChatOnFolderHeader(e, folder.id);
                            }
                          }}
                        >
                          <button
                            title={collapsed ? "ÎåÄÌôî ÌéºÏπòÍ∏∞" : "ÎåÄÌôî Ï†ëÍ∏∞"}
                            aria-label={collapsed ? "ÎåÄÌôî ÌéºÏπòÍ∏∞" : "ÎåÄÌôî Ï†ëÍ∏∞"}
                            onClick={(e) => {
                              e.stopPropagation();
                              toggleFolder(folder.id);
                            }}
                            className="sidebar-folder-toggle"
                          >
                            {collapsed ? "+" : "‚àí"}
                          </button>

                          <span className="sidebar-folder-name">{folder.name}</span>

                          <div class
